package main

/*
Когда функция createHugeString создаёт большую строку (например 1 МБ)
и мы берём срез - v[:100], мы сохраняем в памяти не 100 символов,
а всю строку v, так как строка в Go - это структура с указателем на байты и длиной
когда берем срез v[:100], создаётся новая строка, но указывающая на тот же участок памяти
в результате justString хранит ссылку на весь оригинальный буфер,
из-за чего большая строка не может быть освобождена сборщиком мусора
и если createHugeString вызывается часто, то Это может привести к утечкам памяти
---------------------------------------------------------------------------------
Решение: Нужно скопировать нужный кусок строки в новую строку,
чтобы оригинальный буфер можно было освободить
*/
var justString string

func someFunc() {
	v := createHugeString(1 << 10)
	// Создаём копию первых 100 символов
	justString = v[:100]
}

func main() {
	someFunc()
}

/*
[]rune(v[:100]) преобразует строку в срез рун (символов Unicode)
Это важно, чтобы не "разрезать" символы посередине, если есть не-ASCII символы
string(...) создаёт новую строку с собственной копией памяти
Теперь оригинальная строка v может быть удалена сборщиком мусора, потому что на неё больше нет ссылок
*/
var justString string

func someFunc() {
	v := createHugeString(1 << 10)
	// Создаём копию первых 100 символов
	justString = string([]rune(v[:100]))
	//Если строка гарантированно содержит только ASCII, можно копировать через байты
	justString = string([]byte(v[:100]))
}

func main() {
	someFunc()
}
