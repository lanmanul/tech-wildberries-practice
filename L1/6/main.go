package main

import (
	"context"
	"fmt"
	"runtime"
	"time"
)

func main() {

	/*
		Выход по условию (флаг): горутина периодически проверяет флаг и сама выходит.
	*/

	stopFlag := false // флаг завершения; горутина будет периодически его читать

	// Запускаем горутину
	go func() {
		for { // бесконечный цикл работы горутины
			if stopFlag { // проверяем флаг: если true, то выходим
				fmt.Println("Горутина завершена (флаг).")
				return // выходим из горутины
			}
			fmt.Println("Работаю (флаг)...")   // имитация работы
			time.Sleep(300 * time.Millisecond) // небольшая пауза, чтобы не спамить
		}
	}()

	time.Sleep(2 * time.Second) // даём поработать 2 секунды
	stopFlag = true             // меняем флаг
	time.Sleep(1 * time.Second) // ждём, чтобы горутина успела заметить флаг и выйти

	/*
		Сигнал через канал: отдельный done канал, закрытие которого - транслируемый всем сигнал стоп.
	*/

	stopCh := make(chan struct{}) // канал уведомления о завершении (пустая структура - нулевой оверхед)

	// Запускаем горутину
	go func() {
		for {
			select {
			case <-stopCh: // как только канал закрыли или получили значение — выходим
				fmt.Println("Горутина завершена (канал).")
				return
			default:
				// если сигнала нет — продолжаем работу
				fmt.Println("Работаю (канал)...")
				time.Sleep(500 * time.Millisecond)
			}
		}
	}()

	time.Sleep(2 * time.Second) // даём поработать
	close(stopCh)               // закрываем канал: все слушатели увидят завершение
	time.Sleep(1 * time.Second) // ждём корректного выхода горутины

	/*
		Контекст с отменой (context.WithCancel): прокидываем контекст в горутину; cancel() сигналит о завершении.
	*/

	// Создаём корневой контекст и функцию отмены
	ctx1, cancel1 := context.WithCancel(context.Background())

	// Запускаем горутину, которой передаём контекст
	go func(ctx context.Context) {
		for {
			select {
			case <-ctx.Done(): // как только контекст отменён - Done() закрывается
				fmt.Println("Горутина завершена (context).")
				return
			default:
				fmt.Println("Работаю (context)...")
				time.Sleep(500 * time.Millisecond)
			}
		}
	}(ctx1)

	time.Sleep(2 * time.Second) // даём время на работу
	cancel1()                   // отправляем сигнал отмены для всех, кто слушает этот контекст
	time.Sleep(1 * time.Second) // даём время горутине завершиться

	/*
		Таймаут по времени (time.After): создаём канал-таймер, который сработает через N времени
		Когда таймер сработал — выходим из горутины
	*/

	go func() {
		// time.After вернёт канал, который получит единственное событие через 2 секунды
		timeout := time.After(2 * time.Second)

		for {
			select {
			case <-timeout: // таймер сработал — корректно выходим
				fmt.Println("Горутина завершена (по таймеру).")
				return
			default:
				// пока таймер не сработал — работаем
				fmt.Println("Работаю (таймер)...")
				time.Sleep(500 * time.Millisecond)
			}
		}
	}()

	time.Sleep(3 * time.Second) // ждём, чтобы увидеть работу до таймаута и завершение

	/*
		Принудительная остановка runtime.Goexit(): немедленно завершить текущую горутину.
	*/

	go func() {
		// defer будет вызван даже при Goexit()
		defer fmt.Println("Defer: горутина завершает работу (Goexit).")

		fmt.Println("Горутина начинает работу (Goexit).")
		time.Sleep(1 * time.Second) // немного поработаем
		fmt.Println("Принудительная остановка (Goexit).")
		runtime.Goexit() // немедленно завершает текущую горутину

		// До этой строки выполнение не дойдёт
		// (оставлено для наглядности — вы не увидите этот вывод)
		fmt.Println("Эта строка никогда не выполнится.")
	}()

	time.Sleep(2 * time.Second) // ждём, чтобы увидеть поведение Goexit и defer
}
